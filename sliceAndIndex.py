import numpy as np
# 切片和索引
a = np.arange(1, 20, 2, int)
# 输出结果为[ 1  3  5  7  9 11 13 15 17 19]
# print(a)
# 从索引为2开始，到索引为7终止，步长是2
b = slice(2, 7, 2)
# 输出结果为[ 5  9 13] 即索引是：2,4,6对应的元素
# print(a[b])
# 输出结果同样是[ 5  9 13]
# print(a[2:7:2])
# 切片还可以包括省略号 …，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# 输出结果为
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]
# print(a)
# 输出第二列的元素 结果为[2 5 8]
# print(a[..., 1])
# 输出第一行的元素 结果为[1 2 3]
# print(a[0, ...])
# 输出第二行以及所剩下的元素
# print(a[1:, ...])


# 高级索引 数组除了整数索引还可以布尔索引以及花式索引
x = np.array([[1, 2], [3, 4], [5, 6]])
# 整数数组索引 获取数组中(0,0)，(1,1)和(2,0)位置处的元素。 列表中第一个数组表示行索引，第二个表示列索引
y = x[[0, 1, 2], [0, 1, 0]]
# 输出结果为[1 4 5]
# print(y)

x = np.array([[0,  1,  2], [3,  4,  5], [6,  7,  8], [9,  10,  11]])
row = np.array([[0, 0], [3, 3]])
cols = np.array([[0, 2], [0, 2]])
y = x[row, cols]
# 获取行索引是 [0,0] 和 [3,3]，而列索引是 [0,2] 和 [0,2]的元素
# 输出结果为
# [[ 0  2]
#  [ 9 11]]
# print(y)

# 可以借助切片 : 或 … 与索引数组组合
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# 切割行索引1~2，列索引1~2
b = a[1:3, 1:3]
# print(b)
# 切割行索引1~2，列索引1~2
c = a[1:3, [1, 2]]
# 输出结果为
# [[5 6]
#  [8 9]]
# print(c)

# 布尔索引 通过布尔数组来索引数组
x = np.array([[0,  1,  2], [3,  4,  5], [6,  7,  8], [9,  10,  11]])
# 输出大于5的元素
# [ 6  7  8  9 10 11]
# print(x[x > 5])
# 使用取补运算获取来过滤NaN
a = np.array([np.nan, 1, 2, np.nan, 3, 4, 5])
# 取出数组中不是nan的数据
# print(a[~np.isnan(a)])
# 判断是否为复数np.iscomplex()

# 花式索引
# 花式索引是指利用整数数组进行索引
# 花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整数组作为索引，如果目标数组是一维的，
# 那么索引的结果就是对应位置的元素，如果目标数组是二维的，那么就是对应下标的行。
x = np.arange(12).reshape(4, 3)
# 输出结果为
# [[ 0  1  2]
#  [ 3  4  5]
#  [ 6  7  8]
#  [ 9 10 11]]
print(x)
# 输出结果为[8 4]
print(x[[2, 1], [2, 1]])

# 传入数组的倒序 输出结果为
# [[18 19 20]
#  [24 25 26]
#  [24 25 26]
#  [27 28 29]]
# print(x[[-4, -2, -2, -1]])
# 传入多个索引数组
# print(x)
# 输出结果为1,2行第0,1,2列所对应的元素
# print(x[np.ix_([1, 2], [0, 1, 2])])

# Broadcast广播
# 广播是numpy对不同形状的数组进行数值计算的方式，对数组的算术运算通常在相应的元素上进行。
# 如果两个数组的形状相同，则数组的乘积就是数组对应位相乘
a = np.array([1, 2, 3, 4])
b = np.array([10, 20, 30, 40])
# 输出结果为[ 10  40  90 160]
# print(a*b)

# 当两个数组的形状不相同时触发广播机制 相当于对第二个数组做4次运算
a = np.array([[0, 0, 0],
           [10, 10, 10],
           [20, 20, 20],
           [30, 30, 30]])
b = np.array([1, 2, 3])
# 输出结果为
# [[ 1  2  3]
#  [11 12 13]
#  [21 22 23]
#  [31 32 33]]
# print(a + b)

# 广播机制的同理
# tile()通过给定的数组重复构造数组 构造四个一维数组
b = np.tile(b, (4, 1))
# 输出结果为
# [[ 1  2  3]
#  [11 12 13]
#  [21 22 23]
#  [31 32 33]]
# print(a+b)

# 迭代数组和数组操作
# Numpy迭代器对象numpy.nditer提供了一种灵活访问一个或多个数组元素的方式
# 迭代输出数组元素
a = np.arange(6).reshape(2, 3)
# print(a)
# 输出结果为 1,2,3,4,5,6,
# for x in np.nditer(a):
#    print(x, end=',')
#print('\n')
# a 和 a.T 的遍历顺序是一样的，也就是他们在内存中的存储顺序也是一样的
# 1,2,3,4,5,6,
# for x in np.nditer(a.T):
#    print(x, end=',')
# print('\n')
# a.T.copy(order = 'C') 的遍历结果是不同的，那是因为它和前两种的存储方式是不一样的，默认是按行访问
# for x in np.nditer(a.T.copy(order='C')):
#    print(x, end=',')

a = np.arange(0, 60, 5).reshape(3, 4)
#print(a)
#print(a.T)
# C即是行序优先 F 即是列序优先
b = a.copy(order='C')
#print(b)
# 输出结果为0 5 10 15 20 25 30 35 40 45 50 55
# for x in np.nditer(b):
#    print(x, end=' ')

print('\n')
# 以列序优先遍历
c = a.copy(order='F')
# 输出结果为0 20 40 5 25 45 10 30 50 15 35 55
# for x in np.nditer(c):
#    print(x, end=' ')
print('\n')
# nditer可以显示的指定某种顺序
# for x in np.nditer(a, order='F'):
#    print(x, end=' ')

# 修改数组中元素的值
# nditer对象有另一个可选参数op_flags,默认情况下，nditer将待迭代数组为只读对象（read-only）,
# 为了在遍历数组的同时实现对数组的修改，必须只读read-write或者write-only模式
# 修改后的结果为
# [[  0  10  20  30]
#  [ 40  50  60  70]
#  [ 80  90 100 110]]
# for x in np.nditer(a, op_flags=['readwrite']):
#    x[...] = 2*x
# print(a)
# 给出多个值得一维数组 external_loop给出的值是具有多个值的一维数组，而不是零维数组
# 输出结果为 [ 0 40 80],[10 50 90],[ 20  60 100],[ 30  70 110],
# for x in np.nditer(a, flags=['external_loop'],order='F'):
#    print(x, end=',')

# 广播迭代
# 如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。
# 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）
a = np.arange(0, 60, 5).reshape(3, 4)
b = np.array([1, 2, 3, 4], dtype=int)
# 0:1,5:2,10:3,15:4,20:1,25:2,30:3,35:4,40:1,45:2,50:3,55:4,
# for x, y in np.nditer([a, b]):
#    print("%d:%d" % (x, y), end=',')



